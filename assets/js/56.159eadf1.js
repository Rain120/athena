(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{518:function(t,a,e){"use strict";e.r(a);var h=e(23),o=Object(h.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path"}},[t._v("#")]),t._v(" Path")]),t._v(" "),e("p",[e("code",[t._v("Path")]),t._v(" arrays are a list of indexes that describe a node's exact position in a Slate node tree. Although they are usually relative to the root "),e("code",[t._v("Editor")]),t._v(" object, they can be relative to any "),e("code",[t._v("Node")]),t._v(" object.")]),t._v(" "),e("div",{staticClass:"language-typescript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Path")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("ul",[e("li",[e("RouterLink",{attrs:{to:"/en/slate/locations/path.html#static-methods"}},[t._v("Static methods")]),t._v(" "),e("ul",[e("li",[e("RouterLink",{attrs:{to:"/en/slate/locations/path.html#retrieval-methods"}},[t._v("Retrieval methods")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/en/slate/locations/path.html#check-methods"}},[t._v("Check methods")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/en/slate/locations/path.html#transform-method"}},[t._v("Transform method")])],1)])],1)]),t._v(" "),e("h2",{attrs:{id:"static-methods"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#static-methods"}},[t._v("#")]),t._v(" Static methods")]),t._v(" "),e("h3",{attrs:{id:"retrieval-methods"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#retrieval-methods"}},[t._v("#")]),t._v(" Retrieval methods")]),t._v(" "),e("h4",{attrs:{id:"path-ancestors-path-path-options-reverse-boolean-path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-ancestors-path-path-options-reverse-boolean-path"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.ancestors(path: Path, options: { reverse?: boolean } = {}) => Path[]")])]),t._v(" "),e("p",[t._v("Get a list of ancestor paths for a given path.")]),t._v(" "),e("p",[t._v("The paths are sorted from deepest to shallowest ancestor. However, if the "),e("code",[t._v("reverse: true")]),t._v(" option is passed, they are reversed.")]),t._v(" "),e("h4",{attrs:{id:"path-common-path-path-another-path-path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-common-path-path-another-path-path"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.common(path: Path, another: Path) => Path")])]),t._v(" "),e("p",[t._v("Get the common ancestor path of two paths.")]),t._v(" "),e("h4",{attrs:{id:"path-compare-path-path-another-path-1-0-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-compare-path-path-another-path-1-0-1"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.compare(path: Path, another: Path) => -1 | 0 | 1")])]),t._v(" "),e("p",[t._v("Compare a path to another, returning an integer indicating whether the path was before, at, or after the other.")]),t._v(" "),e("p",[t._v("Note: Two paths of unequal length can still receive a "),e("code",[t._v("0")]),t._v(" result if one is directly above or below the other. If you want exact matching, use [[Path.equals]] instead.")]),t._v(" "),e("h4",{attrs:{id:"path-levels-path-path-options-path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-levels-path-path-options-path"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.levels(path: Path, options?) => Path[]")])]),t._v(" "),e("p",[t._v("Get a list of paths at every level down to a path. Note: this is the same as "),e("code",[t._v("Path.ancestors")]),t._v(", but includes the path itself.")]),t._v(" "),e("p",[t._v("The paths are sorted from shallowest to deepest. However, if the "),e("code",[t._v("reverse: true")]),t._v(" option is passed, they are reversed.")]),t._v(" "),e("p",[t._v("Options: "),e("code",[t._v("{reverse?: boolean}")])]),t._v(" "),e("h4",{attrs:{id:"path-next-path-path-path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-next-path-path-path"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.next(path: Path) => Path")])]),t._v(" "),e("p",[t._v("Given a path, gets the path to the next sibling node. The method does not ensure that the returned "),e("code",[t._v("Path")]),t._v(" is valid in the document.")]),t._v(" "),e("h4",{attrs:{id:"path-parent-path-path-path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-parent-path-path-path"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.parent(path: Path) => Path")])]),t._v(" "),e("p",[t._v("Given a path, return a new path referring to the parent node above it. If the "),e("code",[t._v("path")]),t._v(" argument is equal to "),e("code",[t._v("[]")]),t._v(", throws an error.")]),t._v(" "),e("h4",{attrs:{id:"path-previous-path-path-path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-previous-path-path-path"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.previous(path: Path) => Path")])]),t._v(" "),e("p",[t._v("Given a path, get the path to the previous sibling node. The method will throw an error if there are no previous siblings (e.g. if the Path is currently "),e("code",[t._v("[1, 0]")]),t._v(", the previous path would be "),e("code",[t._v("[1, -1]")]),t._v(" which is illegal and will throw an error).")]),t._v(" "),e("h4",{attrs:{id:"path-relative-path-path-ancestor-path-path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-relative-path-path-ancestor-path-path"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.relative(path: Path, ancestor: Path) => Path")])]),t._v(" "),e("p",[t._v("Given two paths, one that is an ancestor to the other, returns the relative path from the "),e("code",[t._v("ancestor")]),t._v(" argument to the "),e("code",[t._v("path")]),t._v(" argument. If the "),e("code",[t._v("ancestor")]),t._v(" path is not actually an ancestor or equal to the "),e("code",[t._v("path")]),t._v(" argument, throws an error.")]),t._v(" "),e("h3",{attrs:{id:"check-methods"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#check-methods"}},[t._v("#")]),t._v(" Check methods")]),t._v(" "),e("p",[t._v("Check some attribute of a path. Always returns a boolean.")]),t._v(" "),e("h4",{attrs:{id:"path-endsafter-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-endsafter-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.endsAfter(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path ends after one of the indexes in another.")]),t._v(" "),e("h4",{attrs:{id:"path-endsat-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-endsat-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.endsAt(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path ends at one of the indexes in another.")]),t._v(" "),e("h4",{attrs:{id:"path-endsbefore-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-endsbefore-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.endsBefore(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path ends before one of the indexes in another.")]),t._v(" "),e("h4",{attrs:{id:"path-equals-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-equals-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.equals(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path is exactly equal to another.")]),t._v(" "),e("h4",{attrs:{id:"path-hasprevious-path-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-hasprevious-path-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.hasPrevious(path: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if the path of previous sibling node exists")]),t._v(" "),e("h4",{attrs:{id:"path-isafter-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-isafter-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.isAfter(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path is after another.")]),t._v(" "),e("h4",{attrs:{id:"path-isancestor-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-isancestor-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.isAncestor(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path is an ancestor of another.")]),t._v(" "),e("h4",{attrs:{id:"path-isbefore-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-isbefore-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.isBefore(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path is before another.")]),t._v(" "),e("h4",{attrs:{id:"path-ischild-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-ischild-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.isChild(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path is a child of another.")]),t._v(" "),e("h4",{attrs:{id:"path-iscommon-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-iscommon-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.isCommon(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path is equal to or an ancestor of another.")]),t._v(" "),e("h4",{attrs:{id:"path-isdescendant-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-isdescendant-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.isDescendant(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path is a descendant of another.")]),t._v(" "),e("h4",{attrs:{id:"path-isparent-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-isparent-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.isParent(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path is the parent of another.")]),t._v(" "),e("h4",{attrs:{id:"path-ispath-value-any-value-is-path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-ispath-value-any-value-is-path"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.isPath(value: any) => value is Path")])]),t._v(" "),e("p",[t._v("Check is a value implements the "),e("code",[t._v("Path")]),t._v(" interface.")]),t._v(" "),e("h4",{attrs:{id:"path-issibling-path-path-another-path-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-issibling-path-path-another-path-boolean"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.isSibling(path: Path, another: Path) => boolean")])]),t._v(" "),e("p",[t._v("Check if a path is a sibling of another.")]),t._v(" "),e("h3",{attrs:{id:"transform-method"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transform-method"}},[t._v("#")]),t._v(" Transform method")]),t._v(" "),e("h4",{attrs:{id:"path-transform-path-path-operation-operation-options-path-null"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-transform-path-path-operation-operation-options-path-null"}},[t._v("#")]),t._v(" "),e("code",[t._v("Path.transform(path: Path, operation: Operation, options?) => Path | null")])]),t._v(" "),e("p",[t._v("Transform a path by an operation.")]),t._v(" "),e("p",[t._v("Options: "),e("code",[t._v("{ affinity?: 'forward' | 'backward' | null }")])])])}),[],!1,null,null,null);a.default=o.exports}}]);