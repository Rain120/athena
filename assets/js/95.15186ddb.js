(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{559:function(e,t,a){"use strict";a.r(t);var s=a(23),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"迁移"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迁移"}},[e._v("#")]),e._v(" 迁移")]),e._v(" "),a("p",[e._v("从更早的 Slate 版本迁移到 "),a("code",[e._v("0.50.x")]),e._v(" 版本不是一个简单的任务。整个框架被重构 "),a("code",[e._v("( re-considered from the ground up)")]),e._v(" 。这导致了 "),a("strong",[e._v("更好的")]),e._v(" 抽象，让你可以编写更少的代码。但是迁移过程一点都不简单。")]),e._v(" "),a("p",[e._v("强烈建议你在阅读完这篇指南后，阅读全新的 "),a("RouterLink",{attrs:{to:"/zh/slate/walkthroughs/01-installing-slate.html"}},[e._v("Walkthroughs")]),e._v(" 和另一个 "),a("RouterLink",{attrs:{to:"/zh/slate/concepts/01-interfaces.html"}},[e._v("Concepts")]),e._v(" 来了解如何应用所有新的概念。")],1),e._v(" "),a("h2",{attrs:{id:"主要的区别-major-differences"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要的区别-major-differences"}},[e._v("#")]),e._v(" 主要的区别(Major Differences)")]),e._v(" "),a("p",[e._v("从架构的角度看，这里是 "),a("code",[e._v("0.50.x")]),e._v(" 版本的 "),a("code",[e._v("Slate")]),e._v(" (和之前版本) "),a("em",[e._v("主要")]),e._v(" 区别的概览。")]),e._v(" "),a("h3",{attrs:{id:"json"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json"}},[e._v("#")]),e._v(" JSON!")]),e._v(" "),a("p",[e._v("数据模型现在由简单的 "),a("code",[e._v("JSON")]),e._v(" 对象组成。之前，它使用 "),a("a",{attrs:{href:"https://immutable-js.github.io/immutable-js/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Immutable.js"),a("OutboundLink")],1),e._v(" 数据结构。这是一个巨大的改变，并且它带来了一些其他的东西。它(也很可能)会提升使用 "),a("code",[e._v("Slate")]),e._v(" 的平均性能。它也使新手更容易入门。从中迁移是一个巨大的改变，但是这是值得的！")]),e._v(" "),a("h3",{attrs:{id:"接口-interfaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口-interfaces"}},[e._v("#")]),e._v(" 接口(Interfaces)")]),e._v(" "),a("p",[e._v("数据模型(现在)是基于接口的。之前每一个模型都是一个类的实例。现在, (数据模型)不仅是一个数据纯对象，而且 "),a("code",[e._v("Slate")]),e._v(" 也期待这个对象实现一个接口。所以过去位于 "),a("code",[e._v("node.data")]),e._v(" 的自定义属性现在可以位于节点的顶层。")]),e._v(" "),a("h3",{attrs:{id:"命名空间-namespaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名空间-namespaces"}},[e._v("#")]),e._v(" 命名空间(Namespaces)")]),e._v(" "),a("p",[e._v("在命名空间中，辅助函数集合暴露出大量的辅助函数。比如， "),a("code",[e._v("Node.get(root, path)")]),e._v(" 或者 "),a("code",[e._v("Range.isCollapsed(range)")]),e._v(" 。结果就是使代码更加清晰，因为你总是可以快速查看你正在使用的接口。")]),e._v(" "),a("h3",{attrs:{id:"typescript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[e._v("#")]),e._v(" TypeScript")]),e._v(" "),a("p",[e._v("现在代码库使用 "),a("code",[e._v("TypeScript")]),e._v("。使用纯 "),a("code",[e._v("JSON")]),e._v(" 作为数据模型，并且使用基于接口的 "),a("code",[e._v("API")]),e._v("， 通过迁移到 "),a("code",[e._v("TypeScript")]),e._v(" 可以简化这两件事。你不需要自己使用它，但是如果你使用它，则在使用 "),a("code",[e._v("API")]),e._v(" 的时候会获得更多的安全性。 (而且，如果你使用 "),a("code",[e._v("VS Code")]),e._v("，无论如何你都会获得更好的自动补全！)")]),e._v(" "),a("h3",{attrs:{id:"更少的概念-fewer-concepts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更少的概念-fewer-concepts"}},[e._v("#")]),e._v(" 更少的概念(Fewer Concepts)")]),e._v(" "),a("p",[e._v("接口和命令的数量已经减少了。之前的 "),a("code",[e._v("Selection")]),e._v("， "),a("code",[e._v("Annotation")]),e._v(" 和 "),a("code",[e._v("Decoration")]),e._v(" 曾经是单独的类。现在它们是实现 "),a("code",[e._v("Range")]),e._v(" 接口的简单对象。之前的 "),a("code",[e._v("Block")]),e._v(" 和 "),a("code",[e._v("Inline")]),e._v(" 是单独定义的，现在它们是一个实现 "),a("code",[e._v("Element")]),e._v(" 接口的对象。 之前有 "),a("code",[e._v("Document")]),e._v(" 和 "),a("code",[e._v("Value")]),e._v("，但是现在顶级的 "),a("code",[e._v("Editor")]),e._v(" 节点包含了文档本身的子节点。")]),e._v(" "),a("p",[e._v("命令的数量也减少了。之前我们每一个输入类型都拥有一个命令，像是 "),a("code",[e._v("insertText")]),e._v("， "),a("code",[e._v("insertTextAtRange")]),e._v(" 和 "),a("code",[e._v("insertTextAtPath")]),e._v("。它们已经被合并到一个更可定制的命令的更小的集合，比如 "),a("code",[e._v("insertText")]),e._v(" 可以在 "),a("code",[e._v("Path | Range | Point")]),e._v(" 中使用。")]),e._v(" "),a("h3",{attrs:{id:"更少的包-fewer-packages"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更少的包-fewer-packages"}},[e._v("#")]),e._v(" 更少的包(Fewer Packages)")]),e._v(" "),a("p",[e._v("为了减轻维护负担，和因为 "),a("code",[e._v("Slate")]),e._v(" 核心新的抽象和 "),a("code",[e._v("API")]),e._v("， (它们) 使事情变得更加容易， (所以) 目前包的数量已经减少了。 像是 "),a("code",[e._v("slate-plain-serializer")]),e._v("， "),a("code",[e._v("slate-base64-serializer")]),e._v("等已经被移除了，并且如果需要的话，可以在用户域中轻松实现。甚至 "),a("code",[e._v("slate-html-deserializer")]),e._v(" 可以在用户域中实现  "),a("code",[e._v("(in ~10 LOC leveraging slate-hyperscript)")]),e._v("。并且不再暴露像是 "),a("code",[e._v("slate-dev-environment")]),e._v("， "),a("code",[e._v("slate-dev-test-utils")]),e._v("之类的内部包，因为它们是实现细节。")]),e._v(" "),a("h3",{attrs:{id:"命令-commands"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令-commands"}},[e._v("#")]),e._v(" 命令(Commands)")]),e._v(" "),a("p",[e._v("添加了新的命令概念。 (旧的命令概念现在被称为转换："),a("code",[e._v("transforms")]),e._v("。)新概念表达了用户编辑文档的语义化意图。并且它们允许对用户行为进行正确的抽象 — 比如改变当用户按下回车键或删除键时发生的情况等等。你应该重写命令行为来代替使用 "),a("code",[e._v("keydown")]),e._v(" 事件。")]),e._v(" "),a("p",[e._v("命令通过调用 "),a("code",[e._v("editor.*")]),e._v(" 的核心函数来触发。然后会依次通过类似中间层的栈，但是它们是由合成函数构建的。任何插件都可以通过重写编辑器行为来扩展它。")]),e._v(" "),a("h3",{attrs:{id:"插件-plugins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件-plugins"}},[e._v("#")]),e._v(" 插件(Plugins)")]),e._v(" "),a("p",[e._v("插件现在是一个纯函数，可以增强接收到的 "),a("code",[e._v("Editor")]),e._v(" 对象并且返回它们。比如可以通过编写 "),a("code",[e._v("editor.exec")]),e._v(" 函数来增强命令执行。或者通过编写 "),a("code",[e._v("editor.apply")]),e._v(" 来监听操作。之前它们依靠自定义的中间件栈，它们只是合成到编辑器的处理程序。现在我们使用纯的老的函数合成方式 (也称为包装："),a("code",[e._v("wrapping")]),e._v(") 来替代它。")]),e._v(" "),a("h3",{attrs:{id:"元素-elements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元素-elements"}},[e._v("#")]),e._v(" 元素(Elements)")]),e._v(" "),a("p",[e._v("块元素和行内元素现在是运行时进行的选择。之前它是被通过 "),a("code",[e._v("object: 'block'")]),e._v(" 或者 "),a("code",[e._v("object: 'inline'")]),e._v(" 属性被绑定到数据模型中的。现在，它在运行时检查一个元素是否是行内元素。比如，你可能需要检查 "),a("code",[e._v("element.type === 'link'")]),e._v(" ，然后把它看作是一个行内元素。")]),e._v(" "),a("h3",{attrs:{id:"更加react化-more-react-ish"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更加react化-more-react-ish"}},[e._v("#")]),e._v(" 更加React化(More React-ish)")]),e._v(" "),a("p",[e._v("插件已经不再关心渲染和事件处理。之前插件可以完全控制渲染逻辑和编辑器事件处理逻辑，这产生了一个坏的激励：把"),a("strong",[e._v("所有的")]),e._v("渲染逻辑放到插件里面，这导致了 Slate 完全被 React 包装 (这很难做好) 。取而代之的是，现在新的行为是插件只专注在富文本方面，而把渲染和事件处理交给 React。")]),e._v(" "),a("h3",{attrs:{id:"上下文-context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文-context"}},[e._v("#")]),e._v(" 上下文(Context)")]),e._v(" "),a("p",[e._v("之前 "),a("code",[e._v("<Editor>")]),e._v(" 组件不光是一个控制器对象，还是可编辑的 DOM 元素。这给其它 Slate 组件和它一起使用带来了大量的问题。在新版本中，有一个新的 "),a("code",[e._v("<Slate>")]),e._v(" 上下文 (provider) 组件，和一个更简单的 "),a("code",[e._v("<Editable>")]),e._v(" 类 "),a("code",[e._v("contenteditable")]),e._v(" 组件。通过提升 "),a("code",[e._v("<Slate>")]),e._v(" 上下文到你的组件树中更高的位置，你可以使用 "),a("code",[e._v("useSlate")]),e._v(" hook 把编辑器分享给工具栏，按钮等等。")]),e._v(" "),a("h3",{attrs:{id:"hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[e._v("#")]),e._v(" Hooks")]),e._v(" "),a("p",[e._v("除了 "),a("code",[e._v("useSlate")]),e._v(" hook，还有一些其它的 hooks。比如 "),a("code",[e._v("useSelected")]),e._v(" 和 "),a("code",[e._v("useFocused")]),e._v(" hooks 有助于了解何时渲染被选择的状态 (通常用于空节点) 。并且因为使用 React 的 Context API，当状态发生变化的时候它们会自动重新渲染。")]),e._v(" "),a("h3",{attrs:{id:"beforeinput"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforeinput"}},[e._v("#")]),e._v(" "),a("code",[e._v("beforeinput")])]),e._v(" "),a("p",[e._v("我们现在一般只使用 "),a("code",[e._v("beforeinput")]),e._v(" 事件。代替依赖一系列的 "),a("code",[e._v("shims")]),e._v(" 和 "),a("code",[e._v("React")]),e._v(" 合成事件的奇怪行为，我们现在使用标准的 "),a("code",[e._v("beforeinput")]),e._v(" 事件作为我们的基础。它完全支持 "),a("code",[e._v("Safari")]),e._v(" 和 "),a("code",[e._v("Chrome")]),e._v(", 不久后就会支持新的基于 "),a("code",[e._v("Chromium")]),e._v(" 内核的 "),a("code",[e._v("Edge")]),e._v("，并且目前已经可以在 Firefox 上使用了。与此同时，我们有一些针对 "),a("code",[e._v("Firefox")]),e._v(" 的补丁让它运行。开箱即用的 "),a("code",[e._v("Slate")]),e._v(" 核心不再支持 "),a("code",[e._v("Internet Explorer")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"history-less"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history-less"}},[e._v("#")]),e._v(" History-less")]),e._v(" "),a("p",[e._v("现在操作历史的核心逻辑最终被提取到一个独立插件中。这使人们更容易实现自定义的操作历史行为。并且确保了插件有足够的控制权以复杂的方式增强编辑器，因为历史记录需要它。")]),e._v(" "),a("h3",{attrs:{id:"无标记-mark-less"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无标记-mark-less"}},[e._v("#")]),e._v(" 无标记(Mark-less)")]),e._v(" "),a("p",[e._v("标记已经被从 "),a("code",[e._v("Slate")]),e._v(" 数据模型移除。现在我们有能力正确地在节点上定义自定义属性，你可以为文本节点的自定义属性建立标记模型。比如加粗可以被简单的建模为 "),a("code",[e._v("bold: true")]),e._v(" 属性。")]),e._v(" "),a("h3",{attrs:{id:"无注释-annotation-less"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无注释-annotation-less"}},[e._v("#")]),e._v(" 无注释(Annotation-less)")]),e._v(" "),a("p",[e._v("熟悉地，注释 ("),a("code",[e._v("annotations")]),e._v(")已经从 "),a("code",[e._v("Slate")]),e._v(" 核心移除。现在，通过定义自定义操作和使用装饰 ("),a("code",[e._v("decorations")]),e._v(")来渲染注释范围，从而完整地实现在用户环境 ("),a("code",[e._v("userland")]),e._v(")中。但是大多数情况下应该使用自定义文本节点属性或者装饰。没有多少使用注释受益的用例。")]),e._v(" "),a("h2",{attrs:{id:"减少体积-reductions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#减少体积-reductions"}},[e._v("#")]),e._v(" 减少体积(Reductions)")]),e._v(" "),a("p",[e._v("一个目标是大大简化 "),a("code",[e._v("Slate")]),e._v(" 的大量逻辑使它更容易理解和迭代。这可以通过重构为更好的抽象表达来做到 (凭借现代 "),a("code",[e._v("DOM API")]),e._v("，和迁移到更简单的 "),a("code",[e._v("React")]),e._v(" 模式)。")]),e._v(" "),a("p",[e._v("使你对总代码行数的更改有所了解:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("slate                       8,436  ->  3,958  (47%)\nslate-react                 3,905  ->  1,954  (50%)\n\nslate-base64-serializer        38  ->      0\nslate-dev-benchmark           340  ->      0\nslate-dev-environment         102  ->      0\nslate-dev-test-utils           44  ->      0\nslate-history                   0  ->    211\nslate-hotkeys                  62  ->      0\nslate-html-serializer         253  ->      0\nslate-hyperscript             447  ->    345\nslate-plain-serializer         56  ->      0\nslate-prop-types               62  ->      0\nslate-react-placeholder        62  ->      0\n\ntotal                      13,807  ->  6,468  (47%)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("p",[e._v("这是相当大的变化！这甚至不包括(框架逻辑)流程中摆脱的依赖关系。")])])}),[],!1,null,null,null);t.default=v.exports}}]);