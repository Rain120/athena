(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{509:function(e,t,a){"use strict";a.r(t);var s=a(23),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"migrating"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#migrating"}},[e._v("#")]),e._v(" Migrating")]),e._v(" "),a("p",[e._v("Migrating from earlier versions of Slate to the "),a("code",[e._v("0.50.x")]),e._v(" versions is not a simple task. The entire framework was re-considered from the ground up. This has resulted in a "),a("strong",[e._v("much")]),e._v(" better set of abstractions, which will result in you writing less code. But the migration process is not simple.")]),e._v(" "),a("p",[e._v("It's highly recommended that after reading this guide you read through the original "),a("RouterLink",{attrs:{to:"/en/slate/walkthroughs/01-installing-slate.html"}},[e._v("Walkthroughs")]),e._v(" and the other "),a("RouterLink",{attrs:{to:"/en/slate/concepts/01-interfaces.html"}},[e._v("Concepts")]),e._v(" to see how all of the new concepts get applied.")],1),e._v(" "),a("h2",{attrs:{id:"major-differences"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#major-differences"}},[e._v("#")]),e._v(" Major Differences")]),e._v(" "),a("p",[e._v("Here's an overview of the "),a("em",[e._v("major")]),e._v(" differences in the "),a("code",[e._v("0.50.x")]),e._v(" version of Slate from an architectural point of view.")]),e._v(" "),a("h3",{attrs:{id:"json"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json"}},[e._v("#")]),e._v(" JSON!")]),e._v(" "),a("p",[e._v("The data model is now comprised of simple JSON objects. Previously, it used "),a("a",{attrs:{href:"https://immutable-js.github.io/immutable-js/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Immutable.js"),a("OutboundLink")],1),e._v(" data structures. This is a huge change, and one that unlocks many other things. Hopefully it will also increase the average performance when using Slate. It also makes it much easier to get started for newcomers. This will be a large change to migrate from, but it will be worth it.")]),e._v(" "),a("h3",{attrs:{id:"interfaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interfaces"}},[e._v("#")]),e._v(" Interfaces")]),e._v(" "),a("p",[e._v("The data model is interface-based. Previously each model was an instance of a class. Now, not only is the data plain objects, but Slate only expects that the objects implement an interface. So custom properties that used to live in "),a("code",[e._v("node.data")]),e._v(" can now live at the top-level of the nodes.")]),e._v(" "),a("h3",{attrs:{id:"namespaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#namespaces"}},[e._v("#")]),e._v(" Namespaces")]),e._v(" "),a("p",[e._v("A lot of helper functions are exposed as a collection of helper functions on a namespace. For example, "),a("code",[e._v("Node.get(root, path)")]),e._v(" or "),a("code",[e._v("Range.isCollapsed(range)")]),e._v(". This ends up making code much clearer because you can always quickly see what interface you're working with.")]),e._v(" "),a("h3",{attrs:{id:"typescript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[e._v("#")]),e._v(" TypeScript")]),e._v(" "),a("p",[e._v("The codebase now uses TypeScript. Working with pure JSON as a data model, and using an interface-based API are two things that have been made easier by migrating to TypeScript. You don't need to use it yourself, but if you do you'll get a lot more security when using the APIs. (And if you use VS Code you'll get nice autocompletion regardless!)")]),e._v(" "),a("h3",{attrs:{id:"fewer-concepts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fewer-concepts"}},[e._v("#")]),e._v(" Fewer Concepts")]),e._v(" "),a("p",[e._v("The number of interfaces and commands has been reduced. Previously "),a("code",[e._v("Selection")]),e._v(", "),a("code",[e._v("Annotation")]),e._v(", and "),a("code",[e._v("Decoration")]),e._v(" used to all be separate classes. Now they are simply objects that implement the "),a("code",[e._v("Range")]),e._v(" interface. Previously "),a("code",[e._v("Block")]),e._v(" and "),a("code",[e._v("Inline")]),e._v(" were separate; now they are objects that implement the "),a("code",[e._v("Element")]),e._v(" interface. Previously there was a "),a("code",[e._v("Document")]),e._v(" and "),a("code",[e._v("Value")]),e._v(", but now the top-level "),a("code",[e._v("Editor")]),e._v(" contains the children nodes of the document itself.")]),e._v(" "),a("p",[e._v("The number of commands has been reduced too. Previously we had commands for every type of input, like "),a("code",[e._v("insertText")]),e._v(", "),a("code",[e._v("insertTextAtRange")]),e._v(", "),a("code",[e._v("insertTextAtPath")]),e._v(". These have been merged into a smaller set of more customizable commands, eg. "),a("code",[e._v("insertText")]),e._v(" which can take "),a("code",[e._v("at: Path | Range | Point")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"fewer-packages"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fewer-packages"}},[e._v("#")]),e._v(" Fewer Packages")]),e._v(" "),a("p",[e._v("In an attempt to decrease the maintenance burden, and because the new abstraction and APIs in Slate's core packages make things much easier, the total number of packages has been reduced. Things like "),a("code",[e._v("slate-plain-serializer")]),e._v(", "),a("code",[e._v("slate-base64-serializer")]),e._v(", etc. have been removed and can be implemented in userland easily if needed. Even the "),a("code",[e._v("slate-html-deserializer")]),e._v(" can now be implemented in userland (in ~10 LOC leveraging "),a("code",[e._v("slate-hyperscript")]),e._v("). And internal packages like "),a("code",[e._v("slate-dev-environment")]),e._v(", "),a("code",[e._v("slate-dev-test-utils")]),e._v(", etc. are no longer exposed because they are implementation details.")]),e._v(" "),a("h3",{attrs:{id:"commands"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commands"}},[e._v("#")]),e._v(" Commands")]),e._v(" "),a("p",[e._v('A new "command" concept has been introduced. (The old "commands" are now called "transforms".) This new concept expresses the semantic intent of a user editing the document. And they allow for the right abstraction to tap into user behaviorsâ€”for example to change what happens when a user presses enter, or backspace, etc. Instead of using '),a("code",[e._v("keydown")]),e._v(" events you should likely override command behaviors instead.")]),e._v(" "),a("p",[e._v("Commands are triggered by calling the "),a("code",[e._v("editor.*")]),e._v(" core functions. And they travel through a middleware-like stack, but built from composed functions. Any plugin can override the behaviors to augment an editor.")]),e._v(" "),a("h3",{attrs:{id:"plugins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#plugins"}},[e._v("#")]),e._v(" Plugins")]),e._v(" "),a("p",[e._v("Plugins are now plain functions that augment the "),a("code",[e._v("Editor")]),e._v(" object they receive and return it again. For example, they can augment the command execution by composing the "),a("code",[e._v("editor.exec")]),e._v(" function or listen to operations by composing "),a("code",[e._v("editor.apply")]),e._v(". Previously they relied on a custom middleware stack, and they were just bags of handlers that got merged onto an editor. Now we're using plain old function composition (aka wrapping) instead.")]),e._v(" "),a("h3",{attrs:{id:"elements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#elements"}},[e._v("#")]),e._v(" Elements")]),e._v(" "),a("p",[e._v("Block-ness and inline-ness is now a runtime choice. Previously it was baked into the data model with the "),a("code",[e._v("object: 'block'")]),e._v(" or "),a("code",[e._v("object: 'inline'")]),e._v(' attributes. Now, it checks whether an "element" is inline or not at runtime. For example, you might check to see that '),a("code",[e._v("element.type === 'link'")]),e._v(" and treat it as inline.")]),e._v(" "),a("h3",{attrs:{id:"more-react-ish"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#more-react-ish"}},[e._v("#")]),e._v(" More React-ish")]),e._v(" "),a("p",[e._v("Rendering and event-handling are no longer a plugin's concern. Previously plugins had full control over the rendering and event-handling logic in the editor. This creates a bad incentive to start putting "),a("strong",[e._v("all")]),e._v(" rendering logic in plugins, which puts Slate in a position of being a wrapper around all of React, which is very hard to do well. Instead, the new architecture has plugins focused purely on the richtext aspects, and leaves the rendering and event handling aspects to React.")]),e._v(" "),a("h3",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" Context")]),e._v(" "),a("p",[e._v("Previously the "),a("code",[e._v("<Editor>")]),e._v(' component was doing double duty as a sort of "controller" object and also the '),a("code",[e._v("contenteditable")]),e._v(" DOM element. This led to a lot of awkwardness in how other components worked with Slate. In the new version, there is a new "),a("code",[e._v("<Slate>")]),e._v(" context provider and a simpler "),a("code",[e._v("<Editable>")]),e._v(" "),a("code",[e._v("contenteditable")]),e._v("-like component. By putting the "),a("code",[e._v("<Slate>")]),e._v(" provider higher up in your component tree, you can share the editor directly with toolbars, buttons, etc. using the "),a("code",[e._v("useSlate")]),e._v(" hook.")]),e._v(" "),a("h3",{attrs:{id:"hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[e._v("#")]),e._v(" Hooks")]),e._v(" "),a("p",[e._v("In addition to the "),a("code",[e._v("useSlate")]),e._v(" hook, there are a handful of other hooks. For example the "),a("code",[e._v("useSelected")]),e._v(" and "),a("code",[e._v("useFocused")]),e._v(" hooks help with knowing when to render selected states (often for void nodes). And since they use React's Context API they will automatically re-render when their state changes.")]),e._v(" "),a("h3",{attrs:{id:"beforeinput"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforeinput"}},[e._v("#")]),e._v(" "),a("code",[e._v("beforeinput")])]),e._v(" "),a("p",[e._v("We now use the "),a("code",[e._v("beforeinput")]),e._v(" event almost exclusively. Instead of relying on a series of shims and the quirks of React synthetic events, we're now using the standardized "),a("code",[e._v("beforeinput")]),e._v(" event as our baseline. It is fully supported in Safari and Chrome, will soon be supported in the new Chromium-based Edge, and is currently being worked on in Firefox. In the meantime there are a few patches to make Firefox work. Internet Explorer is no longer supported in core out of the box.")]),e._v(" "),a("h3",{attrs:{id:"history-less"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history-less"}},[e._v("#")]),e._v(" History-less")]),e._v(" "),a("p",[e._v("The core history logic has now finally been extracted into a standalone plugin. This makes it much easier for people to implement their own custom history behaviors. And it ensures that plugins have enough control to augment the editor in complex ways, because the history requires it.")]),e._v(" "),a("h3",{attrs:{id:"mark-less"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mark-less"}},[e._v("#")]),e._v(" Mark-less")]),e._v(" "),a("p",[e._v("Marks have been removed from the Slate data model. Now that we have the ability to define custom properties right on the nodes themselves, you can model marks as custom properties of text nodes. For example bold can be modelled simply as a "),a("code",[e._v("bold: true")]),e._v(" property.")]),e._v(" "),a("h3",{attrs:{id:"annotation-less"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#annotation-less"}},[e._v("#")]),e._v(" Annotation-less")]),e._v(" "),a("p",[e._v("Similarly, annotations have been removed from Slate's core. They can be fully implemented now in userland by defining custom operations and rendering annotated ranges using decorations. But most cases should be using custom text node properties or decorations anyways. There were not that many use cases that benefited from annotations.")]),e._v(" "),a("h2",{attrs:{id:"reductions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reductions"}},[e._v("#")]),e._v(" Reductions")]),e._v(" "),a("p",[e._v("One of the goals was to dramatically simplify a lot of the logic in Slate to make it easier to maintain and iterate on. This was done by refactoring to better base abstractions that can be built on, by leveraging modern DOM APIs, and by migrating to simpler React patterns.")]),e._v(" "),a("p",[e._v("To give you a sense for the change in total lines of code:")]),e._v(" "),a("div",{staticClass:"language-text line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("slate                       8,436  ->  3,958  (47%)\nslate-react                 3,905  ->  1,954  (50%)\n\nslate-base64-serializer        38  ->      0\nslate-dev-benchmark           340  ->      0\nslate-dev-environment         102  ->      0\nslate-dev-test-utils           44  ->      0\nslate-history                   0  ->    211\nslate-hotkeys                  62  ->      0\nslate-html-serializer         253  ->      0\nslate-hyperscript             447  ->    345\nslate-plain-serializer         56  ->      0\nslate-prop-types               62  ->      0\nslate-react-placeholder        62  ->      0\n\ntotal                      13,807  ->  6,468  (47%)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("p",[e._v("It's quite a big difference! And that doesn't even include the dependencies that were shed in the process too.")])])}),[],!1,null,null,null);t.default=n.exports}}]);